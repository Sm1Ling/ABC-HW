format PE console

include 'win32a.inc'

entry start

section 'text' code executable readable

start:                  ;call - вызов функции, из которой можно в конце выйти командой ret в то место где она была запущена
        call PrintStart  ;выводим начальный текст
        call GetArraySize  ;получаем нужный размер массива
        call AllocArray     ;Выделяем нужное кол-во места под массив
        call AllocSecondArray ; Выделяем место под второй массив
        call GetArray       ;Ввод массива с клавы
        call ProcessArray     ;Обработка массива1 и записть ответа в массив2
        call PrintResult   ;Вывод массива2
        call FreeArrays    ;Освобождение памяти(чисто для красоты)
        call Stop        ;Подождать чтоб монжно было увидеть результат
        ret



PrintStart:
        invoke printf,str1       ;invoke - "Вызов функции из библиотеки"  - после названия функции аргументы через запятую или пробел
        add esp,4            ; msvcrt.dll (printf scanf ...) это действие должна делать функция где-то внутри себя, но почемуто msvcrt не делает этого и приходится самому, без этого тупо не пашет
        ret         ;возврат в то место где была вызвана функция (call func)

GetArraySize:
        invoke scanf,INTEGER,array_size  ;Считываем с клавы число и записываем по адресу array_size, грубо говоря записываем считаное значение в переменную array_size
        add esp,8     ;надо добавлять 4*кол-во_аргументов
        ret

AllocArray:           ;Выделение памяти под первый массив
        mov eax,[array_size]     ;получаем нужное кол-во ячеек
        shl eax,2           ; умножение на степень двойки (eax=eax*2^2 : eax=eax*4) так как нам надо кол-во_ячеек*4, так как размер ячейки - Int = 4 байта
        invoke malloc,eax      ;malloc - memory alloc, eax байт
        add esp,4
        mov [array],eax       ;начало массива(адрес 1й(0й) ячейки) записываем в array
        ret

AllocSecondArray:              ;Тоже самое делаем с вторым массивом
        mov eax,[array_size]
        shl eax,2
        sub eax,8             ;Только сразу его на 8 байт меньше делаем, так как 1й и последний элемент туда никогда не попадают
        invoke malloc,eax
        add esp,4
        mov [array2],eax
        ret

GetArray:     ;Получаем массив с клавиатуры
        invoke printf,str2,[array_size]    ;Вывод сообщения
        add esp,8

        mov edx,[array]      ;Беру начало массива и циклом записываю
        mov ecx,[array_size]   ;[array_size] раз
        lop:               ;начало цикла
                pusha                         ;сохранить все регистры в стеке
                invoke scanf,INTEGER,edx  ;записываю в [edx] число с клавы(изначально [edx] это первая ячейка), функция может изменить регистры во время своей работы и не вернуть их в изначальные состояния
                add esp,8
                popa        ;загрузить все регистры из стека(если scanf их не вернула в изначальное состояние нас это не коснется)
        add edx,4      ;Сдвигаем "текущий" элемент на 1 вперед(на 4 так как int = 4 байта) на следующей итерации цикла [edx] будет уже 2й ячейкой массива и тд
        dec ecx    ;Уменьшаем счетчик на 1
        jnz lop ;Дословно "Если результат предыдущей операции = 0, то jmp на метку lop" - цикл
        ret

ProcessArray:           ;Обрабатываем массивы
        mov eax,[array]                 ;Берем первую ячейку массива1
        mov ebx,[eax]            ;Её значение записываем в ebx
        mov [first],ebx            ;Значение ebx записываем в переменную для 1го числа массива
        mov ebx,[array_size]     ;получаем размер массива
        dec ebx               ;уменьшаем на 1 (так как надо последнюю ячейку(размер-1))
        shl ebx,2          ;умножаем на 4(int = 4 Байта)
        add eax,ebx           ;прибавляем число к адресу первой ячейки - получаем последнюю
        mov ebx,[eax]     ;записываем в ebx - последнее число
        mov [last],ebx    ;записываем в last - последнее число

        mov eax,[array]    ;первая ячейка массива1
        mov ebx,[first]     ;в ebx первое число
        mov edx,[last]      ;в edx последнее
        mov ecx,[array_size]    ;в ecx кол-во элементов массива, или циклов которые нам надо пройти
        mov edi,[array2]    ;edi первая ячека массива2

        add eax,4     ;сдвигаем на 1 ячейку(так как сразу начинаем обрабатывать с второй ячейки)
        sub ecx,2     ;так как первую и последнюю ячейку не проверяем кол-во_итераций-2

        lop2:        ;начало цикла
                mov esi,[eax]     ;берем "текущее" число из массива1
                cmp esi,ebx    ;сравниваем его с ebx(первое число массива)
                je skip        ;если они равны (е = еqual) то "пропускаем", а точнее продолжаем работу программы с метки skip
                cmp esi,edx    ;так же сравниваем со вторым числом
                je skip          ;если же ни первое ни второе условие не сработало значит надо записать число в 2й массив
                        mov [edi],esi  ;записываем число в "текущую" ячейку массива2
                        add edi,4      ;сразу двигаем "текущую" якейку дальше на 1
                        inc [array_size2]  ;кол-во элементов во втором массива +1
                skip:         ;если сработало условие то начинаем от сюда, или оба условия не сработали и число уже добавлено в массив2
        add eax,4    ;"двигаемся дальше по массиву1" чтобы на следующей интерации обрабатывали уже следующее число
        dec ecx    ;счетчик
        jnz lop2   ;если еще не конец то идем в начало
        ret

PrintResult:           ;Вывод результата
        invoke printf,str3
        add esp,4

        mov eax,[array2]         ;Получаем первый элемент массива2
        mov ecx,[array_size2]    ;Получаем размер массива2

        lop3:                ;начало цикла
                pusha                 ;сохраняем регистры в стеке
                invoke printf,INTEGER2,[eax]     ;выводим "текущий" элемент массива
                add esp,8
                popa                      ;загружаем регистры
        add eax,4      ;сдвигаем "текущий" элемент массива на 1 ячеку дальше
        dec ecx       ;уменьшеам счетчик
        jnz lop3                   ;если не конец продолжаем
        ret

FreeArrays:         ;Освобождаем память
        invoke free,[array]
        add esp,4
        invoke free,[array2]
        add esp,4
        ret

Stop:         ;Запращиваем ввод еще одного числа чтобы можно было прочитать ответ
        invoke scanf,INTEGER,array_size
        add esp,8
        ret


section 'data' data readable writeable

first dd ?        ; переменная для 1го числа в массиве
last dd ?            ;для последнего
array_size dd ?     ;для размера 1го массива
array_size2 dd ?       ;для размера 2го
array dd ?       ;для самого 1го массива
array2 dd ?         ;для 2го массива
str1 db 'Enter array size:',13,10,0     ;стоки для вывода,   "13,10" - коды перевода курсора "на следующую строку" и "в начало строки"
str2 db 'Enter %d elements:',13,10,0
str3 db 'Result:',0
INTEGER db '%d',0       ;строка для ввода чисел в scanf
INTEGER2 db ' %d',0    ;для вывода чисел с пробелами между ними

section 'imp' import readable     ;секция импорта

library msvcrt,'msvcrt.dll'  ;нужна библиотека msvcrt.dll

import msvcrt,\             ; в ней нам нужны функции...   (все это стандартные функции Си(Чистый си сам пользуется этой либой))
       printf,'printf',\   ; для вывода
       scanf,'scanf',\      ;для ввода
       malloc,'malloc',\   ;для выделения памяти
       free,'free'          ;для освобождения памяти


